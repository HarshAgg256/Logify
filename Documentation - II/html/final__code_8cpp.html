<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>___________________LOGIC ASSIGNMENT - II: final_code.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Screenshot 2022-12-08 050814.png"/></td>
  <td id="projectalign">
   <div id="projectname">___________________LOGIC ASSIGNMENT - II<span id="projectnumber">&#160;. . . . . . . . PROOF VALIDITY</span>
   </div>
   <div id="projectbrief">_____________________________Group Members : Chinmay Bidarkar, Dev Gaur, Harsh Agarwal , Sreethi Reddy</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('final__code_8cpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">final_code.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class Stack.  <a href="classstack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab5872de50ac861d40bb6dfd66efc90fb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="final__code_8cpp.html#ab5872de50ac861d40bb6dfd66efc90fb">no_of_occurences</a> (string str, char s)</td></tr>
<tr class="memdesc:ab5872de50ac861d40bb6dfd66efc90fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function facilitates in detection of any parenthesization errors in propositional formulas of each proof line in <a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36" title="This function takes note of whether each proof line contains valid propositional formulas with perfec...">formula_validity()</a> function.  <a href="final__code_8cpp.html#ab5872de50ac861d40bb6dfd66efc90fb">More...</a><br /></td></tr>
<tr class="separator:ab5872de50ac861d40bb6dfd66efc90fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bea284141cbe4ae9703917d38dbeec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">is_alpha</a> (char c)</td></tr>
<tr class="memdesc:aa5bea284141cbe4ae9703917d38dbeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the current character is a propositional atom.  <a href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">More...</a><br /></td></tr>
<tr class="separator:aa5bea284141cbe4ae9703917d38dbeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7670fe79833712b610f1cb47ac98d36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36">formula_validity</a> (string formula, int j)</td></tr>
<tr class="memdesc:ac7670fe79833712b610f1cb47ac98d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes note of whether each proof line contains valid propositional formulas with perfect parenthesization.  <a href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36">More...</a><br /></td></tr>
<tr class="separator:ac7670fe79833712b610f1cb47ac98d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebb9a72920dd22fc75ca549d26e9ba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="final__code_8cpp.html#a6ebb9a72920dd22fc75ca549d26e9ba4">checker</a> (string proof[], vector&lt; string &gt; seglist)</td></tr>
<tr class="memdesc:a6ebb9a72920dd22fc75ca549d26e9ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The checker function inspects if the proof rules are implemented correctly in that particular line.  <a href="final__code_8cpp.html#a6ebb9a72920dd22fc75ca549d26e9ba4">More...</a><br /></td></tr>
<tr class="separator:a6ebb9a72920dd22fc75ca549d26e9ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="final__code_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="memdesc:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the main function of our program, that calls other functions, takes input values from the user and displays the outputs.  <a href="final__code_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">More...</a><br /></td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a742204794ea328ba293fe59cec79b990"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="final__code_8cpp.html#a742204794ea328ba293fe59cec79b990">m</a></td></tr>
<tr class="memdesc:a742204794ea328ba293fe59cec79b990"><td class="mdescLeft">&#160;</td><td class="mdescRight">This integer variable stores the current line number of the proof we are on.  <a href="final__code_8cpp.html#a742204794ea328ba293fe59cec79b990">More...</a><br /></td></tr>
<tr class="separator:a742204794ea328ba293fe59cec79b990"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ebb9a72920dd22fc75ca549d26e9ba4" name="a6ebb9a72920dd22fc75ca549d26e9ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebb9a72920dd22fc75ca549d26e9ba4">&#9670;&#160;</a></span>checker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool checker </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>proof</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>seglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The checker function inspects if the proof rules are implemented correctly in that particular line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proof[]</td><td>- The string array containing the entire proof, with each line contained in one row of the vector. </td></tr>
    <tr><td class="paramname">seglist[]</td><td>- This vector contains the divided string containing the propositional formula, proof and the lines the rule is implemented on. </td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md5"></a>
Variables</h3>
<ul>
<li><b>str</b> (String): This variable stores the propositional logic after implementation of the rules.</li>
<li><b>expected_output</b> (String): This variable stores the propositional logic after implementation of the OR introduction rule.</li>
<li><b>s</b> (String): This is the substring of the proof from beginning till the end of proof before /.</li>
<li><b>index</b> (int): This variable stores the position where expected_output is found in the seglist[0].</li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
OR Introduction</h3>
<p >This snippet of the code checks OR introduction rule. It applies the or introduction rule to the element on seglist[2] and checks equivalency with the proof. And based on the outcome returns the value as true or false. The following snippet is for OR introduction 2, the same is done for OR introduction 1.</p>
<div class="fragment"><div class="line">expected_output = <span class="charliteral">&#39;+&#39;</span> + s + <span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line"><span class="keywordtype">bool</span> index = seglist[0].compare(seglist[0].length() - expected_output.length(), expected_output.length(), expected_output);</div>
<div class="line"><span class="keywordflow">if</span>(index == 0)</div>
<div class="line">{</div>
<div class="line">     <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7"></a>
And Introduction</h3>
<p >This snippet of the switch case traverses to those lines on which and introduction rule is implemented, and after implementing the rule stores it in string str. </p><dl class="section note"><dt>Note</dt><dd>This snippet also checks whether the rule implemented on the propositional formulae have occurred before the current proof line.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(stoi((seglist[2]))&gt;=<a class="code hl_variable" href="final__code_8cpp.html#a742204794ea328ba293fe59cec79b990">m</a>||stoi((seglist[3]))&gt;=<a class="code hl_variable" href="final__code_8cpp.html#a742204794ea328ba293fe59cec79b990">m</a>)</div>
<div class="line">     <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">str=<span class="charliteral">&#39;(&#39;</span>+proof[stoi(seglist[2])].substr(0,proof[stoi(seglist[2])].find(<span class="charliteral">&#39;/&#39;</span>))+<span class="charliteral">&#39;*&#39;</span>+proof[stoi(seglist[3])].substr(0,proof[stoi(seglist[3])].find(<span class="charliteral">&#39;/&#39;</span>))+<span class="charliteral">&#39;)&#39;</span>;</div>
<div class="line"><span class="keywordflow">break</span>;</div>
<div class="ttc" id="afinal__code_8cpp_html_a742204794ea328ba293fe59cec79b990"><div class="ttname"><a href="final__code_8cpp.html#a742204794ea328ba293fe59cec79b990">m</a></div><div class="ttdeci">int m</div><div class="ttdoc">This integer variable stores the current line number of the proof we are on.</div><div class="ttdef"><b>Definition:</b> final_code.cpp:8</div></div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md8"></a>
AND ELIMINATION</h3>
<p >We use a stack method to overcome the challenge of multiple and operator within a proof</p>
<p >We run a loop over the whole proof and push " ( " and " ) " inside the stack whenever encountered <br  />
</p>
<p >Whenever there is a pair of "(" and ")" we delete both from the stack</p>
<p >The and operator (*) encountered is only implemented if and only if there is only one " ( " present in the stack at the time of encountering the and symbol</p>
<p >Checking for e1: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;proof[stoi(seglist[2])].length();i++)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(proof[stoi(seglist[2])][i]==<span class="charliteral">&#39;(&#39;</span>)</div>
<div class="line">  {</div>
<div class="line">    st.push(<span class="charliteral">&#39;(&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(proof[stoi(seglist[2])][i]==<span class="charliteral">&#39;)&#39;</span>)</div>
<div class="line">  {</div>
<div class="line">    st.pop();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(proof[stoi(seglist[2])][i]==<span class="charliteral">&#39;*&#39;</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(st.length()==0)</div>
<div class="line">  {</div>
<div class="line">  str=proof[stoi(seglist[2])].substr(1,i-1);</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">}}}</div>
</div><!-- fragment --><p >str string now contains the proof lines until encountering * excluding opening "("</p>
<h3><a class="anchor" id="autotoc_md9"></a>
IMPLICATIONS</h3>
<p >Brief - when ' &gt; ' is detected in a switch case then we enter in this case and check for implication elimination</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Variables -</h2>
<ul>
<li>stack <b>st</b> - object of class stack</li>
<li>string <b>strp</b> - string used to store part of proof line before implication</li>
<li>string <b>stm</b> - string used to store part of proof line in given number until '/' is encountered</li>
<li>string <b>pt</b> - string used to store part of proof line in given number until '/' is encountered</li>
<li>string <b>mp</b> - string used to store part of proof line post implication until '/' is encountered</li>
<li>string <b>kt</b> - string used to store negation of mp</li>
<li>string <b>lt</b> - string used to store negation of lt</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Modus Ponens</h2>
<p >we trim the required proof lines until we find '/' </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> stm = proof[stoi(seglist[2])].substr(0,proof[stoi(seglist[2])].find(<span class="charliteral">&#39;/&#39;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">string</span> pt = proof[stoi(seglist[3])].substr(0,proof[stoi(seglist[3])].find(<span class="charliteral">&#39;/&#39;</span>));</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As discussed in the case of ' * ' we use stack method here too.</dd></dl>
<p>Stack Implementation for Modus Ponens: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;proof[stoi(seglist[2])].length();i++)</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">if</span>(proof[stoi(seglist[2])][i]==<span class="charliteral">&#39;(&#39;</span>)</div>
<div class="line">  {</div>
<div class="line">    st.push(<span class="charliteral">&#39;(&#39;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(proof[stoi(seglist[2])][i]==<span class="charliteral">&#39;)&#39;</span>)</div>
<div class="line">  {</div>
<div class="line">    st.pop();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(proof[stoi(seglist[2])][i]==<span class="charliteral">&#39;&gt;&#39;</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(st.length()==0)</div>
<div class="line">  {</div>
<div class="line">  strp=proof[stoi(seglist[2])].substr(1,i-1);</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">}}}</div>
</div><!-- fragment --><p >We compare the logic code before implication with the next given proof line and also check the logic code post implication with current proof line</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Modus Tollens</h2>
<p >Brief - when ' MT ' is detected in a switch case then we enter in this case and check for possibility of modulus tollens We trim the required proof lines until we find '/'</p>
<dl class="section note"><dt>Note</dt><dd>As discussed in the case of ' * ' we use stack method here too.</dd></dl>
<p>We create seperate strings in order to compare the negations of them with the given proof lines</p>
<p >Negation of Propositional Formula: </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> kt=<span class="charliteral">&#39;~&#39;</span>+mp;</div>
<div class="line"><span class="keywordtype">string</span> lt=<span class="charliteral">&#39;~&#39;</span>+strp;</div>
</div><!-- fragment --><p >We compare the logic code before implication with the negation of current given proof line and also check the logic code post implication with negation of given proof line</p>
<p >Comparing Proofs: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(pt == strp)</div>
<div class="line">{</div>
<div class="line"><span class="keywordflow">if</span>(seglist[0]==mp)</div>
<div class="line"><span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line"><span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>bool value TRUE or FALSE </dd></dl>

</div>
</div>
<a id="ac7670fe79833712b610f1cb47ac98d36" name="ac7670fe79833712b610f1cb47ac98d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7670fe79833712b610f1cb47ac98d36">&#9670;&#160;</a></span>formula_validity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool formula_validity </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>formula</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes note of whether each proof line contains valid propositional formulas with perfect parenthesization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formula</td><td>This string argument stores the propositional formula (&lt;statement&gt;) present in the current line(jth line) of the proof i.e., substring before first '/'. </td></tr>
    <tr><td class="paramname">j</td><td>This integer argument holds the line number we are currently on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns true if the propositional formula is found valid and false if found invalid.</dd></dl>
<h3><a class="anchor" id="autotoc_md2"></a>
Working</h3>
<p >This function first of all calls <a class="el" href="final__code_8cpp.html#ab5872de50ac861d40bb6dfd66efc90fb" title="This function facilitates in detection of any parenthesization errors in propositional formulas of ea...">no_of_occurences()</a> function for checking if number of opening and closing brackets are equal. If not, false is returned and pushed back into trueness array. Otherwise, it carries out a loop to hover over each character of the formula string and check its neighbouring characters. Depending upon a given current character, its neighbouring characters can only be one of the few valid ones. If an invalid neighbouring character is encountered, false is returned and pushed back into trueness array. Else, if all the neighbouring characters of the current character are valid, next iteration is triggered via continue statement to hover over the next character. Encountering zero invalidities leads to return of true value and its pushing back into trueness array.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
If Current Character is a propositional atom:</h3>
<ul>
<li><b>Invalid neighbouring characters on LHS</b> : ')' , an atom</li>
<li><b>Invalid neighbouring characters on RHS</b> : '~' , '(' , an atom</li>
</ul>
<div class="fragment"><div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code hl_function" href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">is_alpha</a>(formula[i]))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(formula[i-1] == <span class="charliteral">&#39;)&#39;</span> || <a class="code hl_function" href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">is_alpha</a>(formula[i-1]) || formula[i+1] == <span class="charliteral">&#39;~&#39;</span> || formula[i+1] == <span class="charliteral">&#39;(&#39;</span> || <a class="code hl_function" href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">is_alpha</a>(formula[i+1]))</div>
<div class="line">    {</div>
<div class="line">        cout&lt;&lt;<span class="stringliteral">&quot;Line number &quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; is Not a Propositional Formula\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="afinal__code_8cpp_html_aa5bea284141cbe4ae9703917d38dbeec"><div class="ttname"><a href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">is_alpha</a></div><div class="ttdeci">bool is_alpha(char c)</div><div class="ttdoc">This function checks if the current character is a propositional atom.</div><div class="ttdef"><b>Definition:</b> final_code.cpp:127</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
If Current Character is an negation operator:</h3>
<ul>
<li><b>Valid neighbouring characters on LHS</b> : '+' , '*' , '&gt;' , '('</li>
<li><b>Valid neighbouring characters on RHS</b> : '(' , an atom</li>
</ul>
<div class="fragment"><div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span>(formula[i]==<span class="charliteral">&#39;~&#39;</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>((formula[i-1] == <span class="charliteral">&#39;+&#39;</span> || formula[i-1] == <span class="charliteral">&#39;*&#39;</span> || formula[i-1] == <span class="charliteral">&#39;&gt;&#39;</span> || formula[i-1] == <span class="charliteral">&#39;(&#39;</span>) &amp;&amp; (<a class="code hl_function" href="final__code_8cpp.html#aa5bea284141cbe4ae9703917d38dbeec">is_alpha</a>(formula[i+1]) ||formula[i+1] == <span class="charliteral">&#39;(&#39;</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        cout&lt;&lt;<span class="stringliteral">&quot;Line number &quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; is Not a Propositional Formula\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> ...... AND SO ON for other current operators </p>

</div>
</div>
<a id="aa5bea284141cbe4ae9703917d38dbeec" name="aa5bea284141cbe4ae9703917d38dbeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bea284141cbe4ae9703917d38dbeec">&#9670;&#160;</a></span>is_alpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_alpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the current character is a propositional atom. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The character which can be an operator, a propositional atom or bracket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns true only if the current character is an English alphabet (small case or capital case). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The user is advised to use only small case English alphabet letters to denote propositional atoms. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36" title="This function takes note of whether each proof line contains valid propositional formulas with perfec...">formula_validity</a> </dd></dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the main function of our program, that calls other functions, takes input values from the user and displays the outputs. </p>
<h3><a class="anchor" id="autotoc_md13"></a>
Variables/Objects</h3>
<ul>
<li><b>no_of_lines (int)</b> : Stores the number of lines the user's proof can be accomodated in.</li>
<li><b>proof [] (String Array)</b> : Array of strings which stores each line of the entered proof i.e., Accessing an element of this array is equivalent to accessing the corresponding line of proof.</li>
<li><b>trueness [] (Bool Array)</b> : This Array of size no_of_lines stores true or false determined/decided by whether the corresponding proof lines contain valid propositional formulas or not.</li>
<li><b>formula (string)</b> : For each iteration, this string stores the propositional formula (&lt;statement&gt;) present in the corresponding line of the proof i.e., substring before first '/'.</li>
<li><b>proof_line (string)</b> : For each iteration, this string stores corresponding line of the proof.</li>
<li><b>segment (string)</b> : For a single line of proof, this string iteratively stores line's segments broken via '/' character.</li>
<li><b>seglist (String Vector)</b> : For a single line of proof, this vector of strings stores the segmented parts of each proof line broken via '/' character.</li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
Working</h3>
<p >After taking no_of_lines and the proof as input from the user, the main function calls for each proof line the <a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36" title="This function takes note of whether each proof line contains valid propositional formulas with perfec...">formula_validity()</a> function to check if the propositional formula is valid or not. If any one of the lines returns false, the program terminates. Otherwise, seglist vector is created and the control goes on to <a class="el" href="final__code_8cpp.html#a6ebb9a72920dd22fc75ca549d26e9ba4" title="The checker function inspects if the proof rules are implemented correctly in that particular line.">checker()</a> function to check if the proof rules are implemented correctly in that particular line. Here is an example of how are things going on in main function:</p>
<div class="image">
<img src="table.png" alt=""/>
</div>
    <dl class="section see"><dt>See also</dt><dd><a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36" title="This function takes note of whether each proof line contains valid propositional formulas with perfec...">formula_validity()</a> </dd>
<dd>
<a class="el" href="final__code_8cpp.html#a6ebb9a72920dd22fc75ca549d26e9ba4" title="The checker function inspects if the proof rules are implemented correctly in that particular line.">checker</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Our main function also prints the line number of error occurence in the proof.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The user has to use:<ul>
<li>'~' for negation operator</li>
<li>'+' for OR operator</li>
<li>'*' for AND operator</li>
<li>'&gt;' for IMPLICATION operator Exercise perfect parenthesization. Don't use '(' before '~' operator in simple formulas like (p+~(q*r)), ~(q&gt;s) It is to be added before '~' only for compound formulas like (~(q+r)*(p&gt;s))</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The program may misbehave if the user enters some alphanumeric strings instead of integer for no_of_lines. </dd></dl>

</div>
</div>
<a id="ab5872de50ac861d40bb6dfd66efc90fb" name="ab5872de50ac861d40bb6dfd66efc90fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5872de50ac861d40bb6dfd66efc90fb">&#9670;&#160;</a></span>no_of_occurences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int no_of_occurences </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function facilitates in detection of any parenthesization errors in propositional formulas of each proof line in <a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36" title="This function takes note of whether each proof line contains valid propositional formulas with perfec...">formula_validity()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>This string contains the propositional formula i.e., substring before first '/' character in each proof line. </td></tr>
    <tr><td class="paramname">s</td><td>This is the character whose number of occurences are to be calculated in string str. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of occurences of character s in string str.</dd></dl>
<h3><a class="anchor" id="autotoc_md1"></a>
Variables</h3>
<ul>
<li><b>count (int)</b> : Stores the count of character s in the input string str.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="final__code_8cpp.html#ac7670fe79833712b610f1cb47ac98d36" title="This function takes note of whether each proof line contains valid propositional formulas with perfec...">formula_validity</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a742204794ea328ba293fe59cec79b990" name="a742204794ea328ba293fe59cec79b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742204794ea328ba293fe59cec79b990">&#9670;&#160;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int m</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This integer variable stores the current line number of the proof we are on. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="final__code_8cpp.html">final_code.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
